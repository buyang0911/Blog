![](https://blog.fastrun.cn/wp-content/uploads/2018/07/timg.jpeg)

> 这是我整理的一套面试题,老铁们看看就当复习了哦

# 概述
感觉现在发面试题有些冷门，就跟昨天德国那场似的，不过看看当提前复习了。提前备战。这2个月出门面试的童鞋可注意不要中暑哦。

## 说几个你所知道的设计模式
### 单例模式

    保证一个类仅有一个实例，并提供一个访问他的全局访问点例如框架中的数据库连接 - 类似DB类
 
### 策略模式 
    针对一组算法，将每一个算法封装到具有共同接口的独立的类中，例如进入个人主页时，根据浏览者的不同，给予不同的显示与操作 - 类似不同用户呈现不同效果
### 注册模式
    提供了在程序中有条理的存放并管理一组全局对象 (object) - 类似服务提供者的注入
### 适配器模式
将不同接口适配成统一的API接口，例如数据操作有mysql、mysqli、pdo等，可利用适配器模式统一接口
### 观察者模式 
 一个对象通过添加一个方法使本身变得可观察。当可观察的对象更改时，它会将消息发送到已注册的观察者。例如实现实现消息推送 - 将所有类的实例化注册到一个数组，通过循环批量执行类
### 装饰器模式 
 不修改原类代码和继承的情况下动态扩展类的功能，例如框架的每个Controller文件会提供before和after方法 - 在某个方法或输出之前执行或之后执行，用于修饰
### 迭代器模式 
 提供一个方法顺序访问一个聚合对象中各个元素，在PHP中将继承 Iterator 类 - yield

# POST和GET有什么区别
  1. GET是从服务器上获取数据，POST是向服务器传送数据
  2. GET是通过发送HTTP协议通过URl参数传递进行接收，而POST是实体数据，通过表单提交
  3. GET传送的数据量较小，不能大于2KB。POST传送的数据量较大，一般被默认为不受限制。
  4. GET安全性非常低，POST安全性较高

# session与cookie的区别
  1. session存储在服务器上的php指定目录中(session_dir)的位置
  2. cookie存储在客户端	

# 数据库中的事务是什么？
指作为一个单元的一组有序的数据库操作，如果组中的所有操作都成功，则认为事务成功，即使有一个操作失败。事务也不成功，如果所有操作完成，事务提交，其修改将作用于所有其他数据库进程，如果有一个操作失败，则事务回滚，该事务影响到的操作都会取消。

# PHP中传引用与传值的区别？
按值传递：函数内对值的内容改变对函数外部无影响
引用传递：函数内对值的内容改变在函数外部也会做出相应修改

# MYSQL优化方案有哪些？
  1. 选用适合的字段类型，避免数据库增加不必要的空间，字段尽量设定为NOTNULL，类似性别，省份尽量使用枚举类型ENUM
  2. 使用JOIN查询代替子查询
  3. 使用UNION代替临时表
  4. 尽量不使用外键、除非必须保持数据表与表之间的一致性、完整性
  5. 尽量不使用视图
  6. 分表分库，读写分离
  7. 合理设置主键及索引
     - 索引分为：普通索引、唯一索引、全文索引、主键（也是一种唯一索引）
  8. 后期演变的数据表优化
      - 垂直拆分：表数据拆分到不同表中，按照业务拆分
      - 水平拆分：行数据拆分到不同表中，按照时间、类型、身份等因素拆分表
      - 水平垂直联合拆分
  9.索引建立原则
      - 最左前缀匹配原则
      - 索引列尽量不参与计算
      - 尽量扩展索引不要新建索引

# 面向对象编程的五个基本原则 (S.O.L.I.D)
  1. SRP 单一功能原则 (你可以这样干，并不是说你应该这样干)
      - 引起类变化的因素永远不要多余一个，保证类的有且只有一个责任
  2. OCP 开闭原则 (开胸手术时不需要穿一件外套)
      - 对扩展开放，对修改闭合
  3. LSP 里氏替换原则
      - 当一个子类的实例应该能够替换任何其父类的实例时，它们之间才具有IS-A关系
  4. ISP 接口隔离原则
      - 不要强迫客户端（泛指调用者）去依赖那些他们不使用的接口
  5. DIP 依赖反转原则
     - 高层模块不应该依赖底层模块，两者都应该依赖其抽象
     - 抽象不应该依赖于细节，细节应该依赖于抽象

# yield的使用
生成器提供了一种更容易的方法来实现简单的对象迭代，相比较定义类实现 Iterator 接口的方式，性能开销和复杂性大大降低。


# 子类重写父类的protected方法有什么限制？
  1. final修饰的类方法不可被子类重写
  2. 5.3以后方法参数个数必须一致
  3. 重写时访问级别只可以等于或者宽松于当前重写方法的访问级别

# 什么是CGI? 什么是FastCGI? php-fpm , FastCGI,Nginx 之间是什么关系？
CGI 是通用网关接口，用户WEB服务器和应用程序间的交互，定义输入输出规范，用户的请求通过WEB服务器转发给FastCGI进程，FastCGI进程再调用应用程式进行处理，如PHP解析器，应用程序的处理结果如HTML返回给FastCGI,FastCGI返回给Nginx进行输出，假设WEB服务器是NGINX,应用程序是PHP,而  php-fpm 是管理FastCGI的，这就是php-fpm,fastCGI与NGINX的关系.

FastCGI 用来提高cgi程序性能，启动一个master,再启动多个worker,不需要每次解析php.ini 而php-fpm实现了fastcgi协议，是fastcgi的进程管理器，支持平滑重启可以启动的时候预先生成多个进程。


# 什么是 CSRF 攻击 ？XSS 攻击？如何防范？
CSRF，跨站请求伪造，攻击方伪装用户身份发送请求从而窃取信息或者破坏系统。
防范
  1. 合理规范api请求方式，GET，POST
  2. 对POST请求加token令牌验证，生成一个随机码并存入session，表单中带上这个随机码，提交的时候服务端进行验证随机码是否相同。

XSS，跨站脚本攻击。
防范
  1. 不相信任何输入，过滤输入。

# 基本算法
##  顺序查找
```
function search($arr,$k){
　　$n = count($arr);
    $arr[$n]= $k;
    for($i=0; $i<$n; $i++){
        if($arr[$i]==$k){
        break;
        }
    }
    if ($i<$n){
        return $i;
    }else{
        return -1;
    }
}
```
##  二分查找
```
function binaryRecursive($arr,$low,$top,$target){
        if($low<=$top){
            $mid = floor(($low+$top)/2);
            if($arr[$mid]==$target){
                return $arr[$mid];
            }elseif($arr[$mid]<$target){
                return binaryRecursive($arr,$mid+1,$top,$target);
            }else{
                return binaryRecursive($arr,$low,$top-1,$target);
            }
        }else{
            return -1;
        }
    }

```

##  冒泡排序
```
function _sort($arr)
	{
		$count = count ($arr) - 1;
		$temp  = 0;
		
		for ($i = 0; $i < $count; $i++) {
		
			for ($j = 0; $j < $count - $i; $j++) {
				if ($arr[$j] < $arr[$j + 1]) {
					$temp        = $arr[$j];
					$arr[$j]     = $arr[$j + 1];
					$arr[$j + 1] = $temp;
				}
			}
		}
		
		return $arr;
	}
```

##  快速排序

```
function quick_sort($arr)
{
    //判断参数是否是一个数组
    if(!is_array($arr)) {
        return false;
    }else{
        //递归出口:数组长度为1，直接返回数组
        $length = count($arr);
        
        if($length<=1) return $arr;
            //数组元素有多个,则定义两个空数组
            $left = $right = array();
            //使用for循环进行遍历，把第一个元素当做比较的对象
            for($i=1; $i<$length; $i++)
            {
                //判断当前元素的大小
                if($arr[$i]<$arr[0]){
                    $left[]=$arr[$i];
                }else{
                    $right[]=$arr[$i];
                }
            }
        //递归调用
        $left=quick_sort($left);
        $right=quick_sort($right);
        //将所有的结果合并
        return array_merge($left,array($arr[0]),$right);
    }
}
```

# NOSQL

## Redis、Memecached 这两者有什么区别？
  1. Redis 支持更加丰富的数据存储类型，String、Hash、List、Set 和 Sorted Set。Memcached 仅支持简单的 key-value 结构。
  2. Memcached key-value存储比 Redis 采用 hash 结构来做 key-value 存储的内存利用率更高。
  3. Redis 提供了事务的功能，可以保证一系列命令的原子性
  4. Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中
  5. Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。

## Redis 如何实现持久化？
  1. RDB 持久化，将 redis 在内存中的的状态保存到硬盘中，相当于备份数据库状态
  2. AOF 持久化（Append-Only-File），AOF 持久化是通过保存 Redis 服务器锁执行的写状态来记录数据库的。相当于备份数据库接收到的命令，所有被写入 AOF 的命令都是以 redis 的协议格式来保存的

# Laravel 设计原理
## 服务提供者是什么？
服务提供者是所有Laravel应用程序引导启动的中心，Laravel的核心服务器、注册服务、绑定服务、监听器、中间件、路由注册以及我们应用程序都是由服务提供者引导启动的。

## IOC容器是什么？
IOC就是控制反转，也被叫做依赖注入(DI),对象A可以依赖对象B,但是控制权在对象A中，所以叫做控制反转，依赖注入则是在IOC容器运行时动态将某种依赖关系注入到对象中。
作用：解决代码难易度，实现低耦合、高扩展

## Facades 是什么？
提供了一个"static"（静态）接口去访问注册到 IoC 容器中的类。提供了简单、易记的语法，而无需记住必须手动注入或配置的长长的类名。此外，由于对 PHP 动态方法的独特用法，也使测试起来非常容易。

## Contract 是什么？
Contract（契约）是 Laravel 定义框架提供的核心服务的接口。Contract 和 Facades 并没有本质意义上的区别，其作用就是使接口低耦合、更简单。

# 架构

## Thrift 实现的基本原理及作用
通过使用RPC通信协议，实现多语言开发场景下无感知的互相调用。
优点
   - 数据包呈二进制发送，流量消耗小
   - 传输效率高
   - 语言之间无障碍

## 如何解决优化网站\App大数据大流量高并发
  - 硬件方面
  - 软件方面
  - 禁止外部盗链
  - 控制大文件的下载
  - 负载均衡
  - 分布式
  - 集群
  - 主从数据库
  - 分布式数据库
  - 分布式缓存

## TCP 三次握手
三次握手就是客户端与服务器端建立TCP连接时需要发送3个包进行连接的确认，在三次握手完成后即可建立连接。
  - 第一次握手。客户端发送请求报文，标志位SYN设置为1，随机产生seq值为x，客户端进入SYN_SENT状态，等待服务器端的回应。
  - 第二次握手。服务器端接收到请求报文，将SYN和ACK都设置为1，ack为x+1，随机产生seq值为y，然后将数据包发送给客户端进行确认，服务器端进入SYN_RCVD状态。
  - 第三次握手。客户端收到回应的数据包后，确认ack是否为x+1，以及ACK是否为1，若正确，则将ACK设置为1，ack为y+1，然后将数据发送给服务器端。服务器端在接受到数据后检查ack是否为y+1，ACK是否为1，若正确则正确建立连接，双方均进入ESTAB-LISHED状态，完成三次握手。

## TCP 与 UDP 的区别

除了TCP之外，我们还常听到的是UDP，那么他俩有啥区别呢？
TCP对应的是可靠性要求高的应用，从上面的解释可以看出来，在真正通信之前要三次握手，是面向连接的；并且TCP利用序列号保证消息的有序性。
而UDP对应的则是可靠性要求低，但是流量大、速度快的应用；和TCP相比，UDP是无连接的并且可能是无序的。
TCP更重量，UDP更轻量，没有高低之分，只是应用的场景不同。

# 非技术问题
1. 为什么要在上家公司离职？
2. 未来三年的职业规划的怎样的？
3. 您这边有什么要理解的吗？
 
> 非技术问题没有正确答案